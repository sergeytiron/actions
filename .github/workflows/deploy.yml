name: Multi-Project Deployment

on:
  push:
    branches:
      - main
    paths:
      - 'project-*/Dockerfile'
      - '.github/workflows/**'
  # Allow manual trigger with options
  workflow_dispatch:
    inputs:
      deploy_all:
        description: 'Deploy all projects regardless of changes'
        required: true
        type: boolean
        default: false
      specific_project:
        description: 'Specific project to deploy (leave empty to auto-detect changes)'
        required: false
        type: string

# IMPORTANT: For the approval gates to work, you MUST configure environments in GitHub:
# 1. Go to your repository settings -> Environments
# 2. Create environments named 'development', 'staging', and 'production'
# 3. For 'staging' and 'production', enable "Required reviewers" and add reviewers
# Without this configuration, the workflow will NOT pause for approval
jobs:
  # Detect changed projects
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 2  # Needed to get the changed files

      # Using Paths Filter to detect changed files
      - name: Filter paths
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            project-main:
              - 'project-main/**'
            project-a:
              - 'project-a/**'
            project-b:
              - 'project-b/**'
      
      # Dynamic matrix generation using a specialized action
      - name: Generate Matrix
        id: set-matrix
        uses: jobily/matrix-includes-builder@v1
        with:
          # Base matrix that will be included if deploy_all is true
          base: |
            [
              {"project_path": "project-main", "project_name": "Main Project", "image_tag": "project-main:latest"},
              {"project_path": "project-a", "project_name": "Project A", "image_tag": "project-a:latest"},
              {"project_path": "project-b", "project_name": "Project B", "image_tag": "project-b:latest"}
            ]
          # Logic for each project
          conditions: |
            [
              {
                "if": "${{ github.event.inputs.deploy_all == 'true' || (github.event.inputs.specific_project == 'project-main' && github.event.inputs.specific_project != '') || steps.filter.outputs.project-main == 'true' }}",
                "value": {"project_path": "project-main", "project_name": "Main Project", "image_tag": "project-main:latest"}
              },
              {
                "if": "${{ github.event.inputs.deploy_all == 'true' || (github.event.inputs.specific_project == 'project-a' && github.event.inputs.specific_project != '') || steps.filter.outputs.project-a == 'true' }}",
                "value": {"project_path": "project-a", "project_name": "Project A", "image_tag": "project-a:latest"}
              },
              {
                "if": "${{ github.event.inputs.deploy_all == 'true' || (github.event.inputs.specific_project == 'project-b' && github.event.inputs.specific_project != '') || steps.filter.outputs.project-b == 'true' }}",
                "value": {"project_path": "project-b", "project_name": "Project B", "image_tag": "project-b:latest"}
              }
            ]

      # Display the matrix for debugging
      - name: Debug matrix output
        run: |
          echo 'Matrix: ${{ steps.set-matrix.outputs.matrix }}'

  # Build and deploy each project in parallel
  build:
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.matrix != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        project: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
      fail-fast: false
    name: Build ${{ matrix.project.project_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build Docker image
        uses: docker/build-push-action@v4
        with:
          context: ${{ matrix.project.project_path }}
          push: false
          load: true
          tags: ${{ matrix.project.image_tag }}
          cache-from: type=gha,scope=${{ matrix.project.project_path }}
          cache-to: type=gha,mode=max,scope=${{ matrix.project.project_path }}

      - name: Save Docker image as artifact
        run: |
          docker save ${{ matrix.project.image_tag }} > docker-image-${{ matrix.project.project_path }}.tar
          
      - name: Upload Docker image as artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ matrix.project.project_path }}
          path: docker-image-${{ matrix.project.project_path }}.tar
          retention-days: 1
          
      - name: Create build info file
        run: |
          echo "${{ matrix.project.project_name }}" > build-info-${{ matrix.project.project_path }}.txt
          echo "${{ matrix.project.image_tag }}" >> build-info-${{ matrix.project.project_path }}.txt
          
      - name: Upload build info as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-info-${{ matrix.project.project_path }}
          path: build-info-${{ matrix.project.project_path }}.txt
          retention-days: 1

  # Deploy to Development Environment
  dev-deployment:
    needs: [detect-changes, build]
    if: ${{ needs.detect-changes.outputs.matrix != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        project: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
      fail-fast: false
    name: Dev - ${{ matrix.project.project_name }}
    environment:
      name: development
    steps:
      - name: Download build info
        uses: actions/download-artifact@v4
        with:
          name: build-info-${{ matrix.project.project_path }}
          
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ matrix.project.project_path }}
          
      - name: Load Docker image
        run: docker load < docker-image-${{ matrix.project.project_path }}.tar
        
      - name: Run container in development
        run: |
          PROJECT_PATH="${{ matrix.project.project_path }}"
          IMAGE_TAG=$(tail -n 1 build-info-${PROJECT_PATH}.txt)
          PROJECT_NAME=$(head -n 1 build-info-${PROJECT_PATH}.txt)
          
          echo "Deploying $PROJECT_NAME to development environment..."
          
          docker run --rm \
            -e ENVIRONMENT="development" \
            -e ENV_CONFIG="Debug mode enabled" \
            ${IMAGE_TAG}
            
          echo "$PROJECT_NAME development deployment completed successfully"

  # Wait for staging approval
  staging-approval:
    needs: dev-deployment
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    steps:
      - name: Approval gate
        run: echo "Deployment to staging environment approved!"

  # Deploy to Staging Environment
  staging-deployment:
    needs: [detect-changes, staging-approval]
    if: ${{ needs.detect-changes.outputs.matrix != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        project: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
      fail-fast: false
    name: Staging - ${{ matrix.project.project_name }}
    steps:
      - name: Download build info
        uses: actions/download-artifact@v4
        with:
          name: build-info-${{ matrix.project.project_path }}
          
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ matrix.project.project_path }}
          
      - name: Load Docker image
        run: docker load < docker-image-${{ matrix.project.project_path }}.tar
        
      - name: Run container in staging
        run: |
          PROJECT_PATH="${{ matrix.project.project_path }}"
          IMAGE_TAG=$(tail -n 1 build-info-${PROJECT_PATH}.txt)
          PROJECT_NAME=$(head -n 1 build-info-${PROJECT_PATH}.txt)
          
          echo "Deploying $PROJECT_NAME to staging environment..."
          
          docker run --rm \
            -e ENVIRONMENT="staging" \
            -e ENV_CONFIG="Performance testing enabled" \
            ${IMAGE_TAG}
            
          echo "$PROJECT_NAME staging deployment completed successfully"

  # Wait for production approval
  production-approval:
    needs: staging-deployment
    runs-on: ubuntu-latest
    environment:
      name: production
      url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    steps:
      - name: Approval gate
        run: echo "Deployment to production environment approved!"

  # Deploy to Production Environment
  production-deployment:
    needs: [detect-changes, production-approval]
    if: ${{ needs.detect-changes.outputs.matrix != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        project: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
      fail-fast: false
    name: Production - ${{ matrix.project.project_name }}
    steps:
      - name: Download build info
        uses: actions/download-artifact@v4
        with:
          name: build-info-${{ matrix.project.project_path }}
          
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ matrix.project.project_path }}
          
      - name: Load Docker image
        run: docker load < docker-image-${{ matrix.project.project_path }}.tar
        
      - name: Run container in production
        run: |
          PROJECT_PATH="${{ matrix.project.project_path }}"
          IMAGE_TAG=$(tail -n 1 build-info-${PROJECT_PATH}.txt)
          PROJECT_NAME=$(head -n 1 build-info-${PROJECT_PATH}.txt)
          
          echo "Deploying $PROJECT_NAME to production environment..."
          
          docker run --rm \
            -e ENVIRONMENT="production" \
            -e ENV_CONFIG="High availability mode" \
            ${IMAGE_TAG}
            
          echo "$PROJECT_NAME production deployment completed successfully"
